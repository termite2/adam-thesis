\chapter{Introduction}

Device driver synthesis has been proposed as a radical alternative to traditional driver development that offers the promise of creating drivers faster and with far fewer defects~\cite{Ryzhyk_CKSH_09}. The idea is to automatically generate the driver code responsible for controlling device operations from a behavioral model of the device and a specification of the driver-OS interface.

The primary motivations for device driver synthesis are the fact that device drivers are hard and tedious to write, and they are notorious for being unreliable~\cite{Chou_YCHE_01,Ganapathi_GP_06}. Drivers generally take a long time to bring to production---given the speed at which new devices can be brought to market today, it is not uncommon for a device release to be delayed by driver rather than silicon issues~\cite{Yavatkar_12}. 

Automatic driver synthesis was proposed in earlier work on the Termite-1 project~\cite{Ryzhyk_CKSH_09}, which formulated the key principles behind the approach and demonstrated its feasibility by synthesizing drivers for several real-world devices.  The next logical step is to develop driver synthesis into a practical methodology, capable of replacing the conventional driver development process.  To this end we have addressed the key problems left open by Termite-1:

\begin{itemize}
    \item The scalability of the Termite-1 synthesis algorithm was severely limited, which made synthesis of drivers for real-world devices intractable. Termite-1 got around the problem by using carefully crafted simplified device specifications, which is acceptable in a proof-of-concept prototype, but not in a practical tool. Addressing this issue is the major contribution of this dissertation.
    \item Termite-1 produced poor quality synthesized code.  While functionally correct, Termite-1 drivers were bloated and poorly structured.  This made it impossible for a programmer to maintain and improve the generated code and prevented synthesized drivers from being adopted by Linux and other major operating systems.  Furthermore, it was impossible to enforce non-functional properties such as CPU and power efficiency.
\end{itemize}

\section{User Guided Synthesis}

Despite substantially improving the scalability of the synthesis algorithm during this work, we came to the conclusion that the approach taken by Termite-1 was \emph{critically flawed}.  The fundamental problem, in our view, was that the synthesis was viewed as a ``push-button'' technology that generated a specification-compliant implementation without any user involvement.  As a result, the user had to rely on the synthesis tool to produce a good implementation.  Unfortunately, even the most intelligent algorithm cannot fully capture the user-perceived notion of high-quality code.  While in theory one might be able to enforce some of the desired properties by adding appropriate constraints to the input specification, in our experience creating such specifications is extremely hard and seldom yields satisfactory results.

A radically different approach was needed---one that combines the power of automation with the flexibility of conventional development, and that involves the developer from the start, guiding the generation of the driver.  In many ways, synthesis and conventional development are conflicting.  Hence, a key challenge was to conceive of a way that allowed the two to be combined so that the developer could do their job more efficiently and with fewer errors without having the synthesis tool get in the way.

This dissertation presents a novel \emph{user-guided} approach to driver synthesis implemented in our new tool called \termite-2 (further referred to as \termite).  In \termite, the user has full control over the synthesis process, while the tool acts as an assistant that suggests, but does not enforce, implementation options and ensures correctness of the resulting code.  At any point during synthesis the user can modify or extend previously synthesized code.  The tool automatically analyses user-provided code and, on user's request, suggests possible ways to extend it to a complete implementation.  If such an extension is not possible due to an error in the user code, the tool generates an explanation of the failure that helps the user to identify and correct the error.

In an extreme scenario, \termite can be used to synthesize the complete implementation fully automatically.  At the other extreme, the user can build the complete implementation by hand, in which case \termite acts as a static verifier for the driver.  In practice, we found the intermediate approach, where most of the code is auto-generated, but manual involvement is used when needed to improve the implementation, to be the most practical.

From the developer's perspective, user-guided synthesis appears as an enhancement of the conventional development process with very powerful autocomplete functionality, rather than a completely new development methodology.  This vision is implemented in all aspects of the design of \termite.  In particular, input specifications for driver synthesis are written as imperative programs that model the behavior of the device and the OS.  The driver itself is modelled as a source code template where parts to be synthesized are omitted.  This approach enables the use of familiar programming techniques in building input specifications.  In contrast, previous synthesis tools, including Termite-1, require specifications to be written in formal languages based on state machines and temporal logic, which proved difficult and error-prone to use even for formal methods experts, not to mention software development practitioners.

Most previous research on automatic synthesis, including Termite-1, considered input specifications to be ``correct by definition''.  In contrast, we recognise that input specifications produced by human developers are likely to contain defects, which can prevent the synthesis algorithm from finding a correct driver implementation.  Therefore \termite incorporates powerful debugging tools that help the developer identify and fix specification defects through well-defined steps, similar to how conventional debuggers help troubleshoot implementation errors.

\section{Scalable Synthesis Algorithm}

Another important contribution of this project is a new scalable synthesis algorithm, which mitigates the computational bottleneck in driver synthesis.  Following the approach proposed in Termite-1, we treat the driver synthesis problem as a two-player game between the driver and its environment, comprised of the device and the OS.  In this work, we develop this approach into the first precise mathematical formulation of the driver synthesis problem based on game theory.  This enables us to apply theoretical results and algorithmic techniques from game theory to driver synthesis.  

Our game-based synthesis algorithm relies on abstraction and symbolic reasoning to achieve orders of magnitude speed up compared to the current state-of-the-art synthesis techniques.  The main idea of the algorithm is described in Section~\ref{s:synthesis}, but we refer the reader to a detailed description in an accompanying publication~\cite{Walker_Ryzhyk_14}. 

%by interactively augmenting or modifying synthesized code as it 
%gets generated.  As long as user-provided code does not violate 
%correctness specifications, the synthesiser is able to extend it 
%to a complete driver implementation.  We call this approach 
%user-guided synthesis.  

%\begin{itemize}
%    \item In this paper, we develop solutions to these problems, 
%        leading to the design and implementation of the first 
%        practical driver synthesis tool, called \termite.  In 
%        particular, we overcome two main barriers to practical 
%        driver synthesis.  The first one is the scalability 
%        barrier.  Existing synthesis algorithms do not scale to 
%        synthesise drivers for real-world devices.  For example, 
%        Termite gets around the problem by using carefully crafted 
%        simplified device specifications, which is acceptable in a     
%        proof-of-concept prototype, but not in a practical tool.
       
%    \item We develop a new algorithm that uses abstraction and 
%        symbolic reasoning to overcome the computational 
%        bottleneck.  In this paper we explain the main idea of the 
%        algorithm and refer the reader to a detailed description 
%        in an accompanying publication~\cite{}.

%    \item The second barrier, and the main focus of this paper, is 
%        the usability barrier.  Previous work on automatic 
%        synthesis, including Termite, views synthesis as a 
%        push-button technology that generates a 
%        specification-compliant implementation without any user 
%        involvement.  This approach takes control over the 
%        resulting driver code away from the user, making it hard 
%        to enforce non-functional properties, such as code clarity 
%        and modularity, CPU and power efficiency, etc.  In 
%        principle, many of these properties can be enforced by 
%        adding appropriate constraints to input specifiation; 
%        however our experiments with early versions of \termite 
%        showed that this approach is difficult to use and seldom 
%        leads to a satisfactory implementation.
%
%    \item A practical synthesis tool must combine the power of 
%        automation with the flexibility of conventional         
%        development.  It should help the developer do their job 
%        more efficiently and with fewer errors without getting in 
%        their way.  


%\end{itemize}

%\paragraph{Code-centric design}
%
%\begin{itemize}
%    \item The \termite synthesis engine works with a low-level 
%        representation of the problem based on finite automata and 
%        temporal logic.  However, it presents the user with the 
%        view of the problem that they can readily understand and 
%        manipulate, namely the source code view.  In particular, 
%        input specifications for driver synthesis are written as 
%        imperative programs that model the behaviour of the device 
%        and the OS.  The driver itself is modelled as a source 
%        code template where parts to be synthesized are omitted.  
%
%%    \item This input is compiled into a low-level specification of 
%%        the game used by the synthesis engine.  The winning 
%%        strategy produced by the engine is lifted back to the 
%%        source code level, so that from the developer's 
%%        perspective synthesis consists of semi-automatically 
%%        filling out missing parts of the driver template.
%%
%%    \item Likewise, if a winning strategy for the driver cannot be 
%%        found, \termite generates an explanation of the synthesis 
%%        failure and presents it to the user by simulating 
%%        problematic program executions over the input specs.
%
%    \item The code-centric approach proved crucial to making 
%        synthesis practical:
%        \begin{itemize}
%            \item It enables the use of familiar programming 
%            abstractions.  In contrast, previous synthesis tools, 
%            including Termite, rely on formal languages, which 
%            proved difficult and error-prone to use even for 
%            formal methods experts, not to mention software 
%            development practitioners.
%
%            \item It enables the developer to work with a single 
%                design artifact from specification, through 
%                debugging, to code generation.
%
%            \item Since both input and output of the tool are in 
%                the same format, driver development and 
%                maintenance can proceed in a closed loop, where 
%                the output of synthesis can be used as an input 
%                specification.  For example, if one of the input 
%                specifications changes, the developer may remove 
%                and resynthesise only the affected parts of the 
%                driver.
%
%            \item It facilitates the re-use of existing high-level 
%                device models developed by hardware designers.  
%                Such models are created for the purposes of 
%                prototyping, testing, and simulation.  With minor 
%                modifications, such existing models can be used in 
%                driver synthesis instead of writing new ones from 
%                scratch.  This is discussed in more detail in 
%                Section~\ref{}.
%        \end{itemize}

%    \item The code-centric approach has a significant 
%        implementation cost, as it requires lifting internal 
%        low-level representation of the game used by \termite to 
%        the source code level at every step of the synthesis 
%        process.  However, it proved crucial to making \termite a 
%        truly practical tool.


%\paragraph{Synthesis, verification, and everything in between}
%
%\begin{itemize}
%
%    \item It is well known in theory that the verification 
%    problem is a special case of the synthesis problem.  However, 
%    \termite is the first tool to take advantage of this in 
%    practice by exposing the entire spectrum between verification 
%    and synthesis to the user.
%
%    \item Since driver specification is a program where some code 
%        is omitted, the user can decide how much to omit.  For 
%        example, they may leave all driver function  
%        implementations blank, in which case the complete driver 
%        implementation will be synthesized.  Alternatively, the 
%        user may provide complete or partial manual implementation 
%        for some of the functions. 
%    
%    \item Note that in writing parts of the driver manually, the 
%        user does not give up the correctness guarantees offerred 
%        by automatic synthesis.  If \termite is able to solve the 
%        game and find an implementation for the remaining parts of 
%        the driver, this guarantess that the resulting 
%        implementation, consisting of manual and synthesized code, 
%        conforms to the correctness specification.
%
%    \item Taking this approach to the extreme, the developer may 
%        implement the driver completely without any omissions.  In 
%        this case, \termite effectively becomes a verification 
%        tool: if synthesis succeeds, this means that user-provided 
%        code satisfies all constraints and goals in the input 
%        specifications.  Alternatively, if synthesis fails, then 
%        the tool generates a counterexample trace that can be used 
%        to find an error in the implementation.
%

We evaluate \termite by synthesizing drivers for several I/O devices.  Our experience demonstrates that our methodology meets our design goals, and indeed makes automatic driver synthesis practical.


\section{Termite}
\section{Chapter outline}
