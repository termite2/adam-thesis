\chapter{Conclusions}

Device driver synthesis is a radical alternative to traditional driver development. It has the potential to drastically reduce the work required to create device drivers and improve their reliability.

This dissertation has presented the design and implementation of the Termite driver synthesis tool. Termite is the first tool to combine automatic game-based synthesis with conventional manual development. It is also the first practical synthesis tool based on abstraction refinement. Finally, it is the first synthesis tool to support automated debugging of input specifications. 

Based on the experimental results of Chapter~\ref{ch:userguided}, I consider Termite to be an important step towards truly practical device driver synthesis.  In particular, the synthesis algorithm is able to efficiently handle real-world device specifications, while the user-guided approach reliably leads to high-quality code.

In order to develop Termite, I created a rigorous game-based formalism of device driver synthesis inspired by Termite-1. This allowed me to apply pre-existing theory and results from the field of reactive synthesis. I created and evaluated a practical predicate-based abstraction refinement algorithm for solving games. To the best of my knowledge, this is the first such algorithm described in the literature. I addressed key performance bottlenecks involved in applying predicate abstraction in game settings and demonstrated that the algorithm performs well on real-world reactive synthesis benchmarks. 

Further research is needed to solve the key remaining problems described in Section~\ref{s:limitations}, primarily the DMA problem, which poses the main obstacle to synthesis of more complex drivers, and the grey-box synthesis problem, which limits the degree of automation achieved by Termite. 

Additional research may explore ways to improve the quality of automatically generated code and thus further reduce the need for user involvement. This includes performance- and power-aware synthesis. Lastly, this approach may be used for the automatic synthesis of hardened device drivers, i.e., drivers that gracefully handle misbehaving devices~\cite{Kadav_RS_09}, by detecting behaviour that deviates from the specification.

